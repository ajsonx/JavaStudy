package day15;

/**
 * Java中使用Thread类，表示一个线程
 * JVM启动会开启一个进程java.exe
 * 在jvm内部，运行java程序，执行多个线程
 * 
 * 进程就是指代码/算法在特定的数据集合上一次执行/运行的活动
 * 		也是系统进行资源分配和调度的基本单位。
 * 线程则是进程的一个执行任务/单元，是进程中的一个实体。
 * 一个进程中至少有一个线程，
 * 进程中的多个线程是共享进程的资源的
 * 
 * 操作系统在分配资源时是把资源分配给进程的，
 * 	但CPU资源比较特殊，是分派到线程级别的，
 * 	因为真正占用CPU运行的是线程，
 * 
 * 将CPU的使用时间，划分为一个一个的时间片，
 * 根据时间片调度分派给线程，只有线程获得CPU的时间片，
 * 	才可占用CPU运行代码。
 * 假设CPU是单核的，同一个时间点，只有一个线程在运行。
 * 		细节微观的看，线程是顺序执行；
 * 		从人类角度宏观的看，是并行的：听歌、写文档等
 * 
 * 进程中有多个线程，多个线程共享进程中的堆和方法区资源，
 * 同时每个线程有自己的栈和程序计数器。
 * 
 * 栈空间，用于存放线程执行中的局部变星，
 * 这些局部变量，是当前线程私有的，其它线程也访问不了。
 * 另外栈还用来存放线程的调用栈帧。
 * 
 * 程序计数器，用来记录线程当前要执行的指令地址。
 * 其实是为了记录让出CPU时间片时执行的地址
 * 
 * 堆是进程中最大的一块内存空间，被进程中所有线程共享。
 * 里面存放的是使用new创建的对象实例。
 * 
 * 方法区，存放的是进程中要执行的代码，被线程共享
 */
public class ThreadDemo01 {
	public static void main(String[] args) {
		
		MThread thread = new MThread();
		thread.start();
			//开启线程：在进程中分配空间，等待CPU调度
			//当thread线程被分配cpu时间片时，开始执行run中的代码
		
		//以下写法，只是一个方法简单调用
		//thread.run();
		//new ThreadDemo01().main(null);
	}
}

//创建线程：定义类，继承Thread
//1)使用继承方式封装线程，导致当前类无法再继承其他类；
//2)执行的任务和代码没有分离开，
//	即多个线程要执行一样的任务时，需要创建多个MyThread的实例
//
//可以借助Runnable接口，直接定义出一个任务类型
class MThread extends Thread {
	
	//将要执行的任务代码，放在run方法中
	//run方法，不能返回值，也不能向上抛出异常
	@Override
	public void run() {
		System.out.println("我是一个线程.");
		System.out.println( this );
				//可以使用this，方便的获得到当前线程对象
				//Thread[Thread-0,5,main]
		//当run方法中代码执行完毕后，
		//该线程就处理终止状态了。
	}
}



